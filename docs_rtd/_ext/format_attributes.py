from sphinx.application import Sphinx
import inspect
import re

_ret_ann: dict[str, str] = {}

def _process_signature(app: Sphinx, what: str, name: str, obj, options, signature, return_annotation):
    if what in ("attribute", "property") and return_annotation:
        _ret_ann[name] = return_annotation
        return signature, None
    return None

def _process_docstring(app: Sphinx, what: str, name: str, obj, options, lines):
    # Clean property/attribute return annotation lines like "(self) -> int"
    if what in ("attribute", "property"):
        # Remove autogenerated (self) -> Type line
        for i, line in list(enumerate(lines)):
            if re.match(r"^\(self\)\s*->\s*", line):
                lines.pop(i)
                break
        t = _ret_ann.pop(name, None)
        if t:
            lines.insert(0, f"Type: {t}")

    # If autodoc misclassifies nanobind callables as attributes, inject a signature line
    if what == "attribute":
        is_callable = callable(obj) or type(obj).__name__.startswith("nb_") or hasattr(obj, "__call__")
        if is_callable:
            try:
                sig = inspect.signature(obj)
                s = f"Signature: {name.split('.')[-1]}{sig}"
                # Prepend signature if not already present
                if not any("Signature:" in l for l in lines):
                    lines.insert(0, s)
            except Exception:
                pass

def setup(app: Sphinx):
    app.connect("autodoc-process-signature", _process_signature)
    app.connect("autodoc-process-docstring", _process_docstring)
    return {"version": "0.2", "parallel_read_safe": True}